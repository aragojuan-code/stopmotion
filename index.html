<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"/>
<title>Stop-Motion con Onion-Skin (10 fotos)</title>
<style>
  :root { --bg:#0f141b; --panel:#121a23; --muted:#9fb3c9; }
  html, body { height:100%; margin:0; background:var(--bg); color:#e6eef7; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial; }
  .wrap { display:flex; flex-direction:column; min-height:100vh; }
  header { padding:10px 14px; display:flex; gap:8px; align-items:center; border-bottom:1px solid rgba(255,255,255,.06); }
  header h1 { font-size:16px; margin:0; font-weight:600; letter-spacing:.2px; }

  main { display:grid; gap:10px; padding:10px; grid-template-columns: 1fr; }
  @media(min-width:880px){ main{ grid-template-columns: minmax(360px,480px) 1fr; } }

  /* Panel c√°mara */
  .cam { background:var(--panel); border:1px solid rgba(255,255,255,.06); border-radius:14px; padding:10px; display:grid; gap:10px; }
  .stage { position:relative; width:100%; border-radius:12px; overflow:hidden; background:#000; }

  /* üîß Tama√±o adaptable:
     - M√≥viles en vertical: altura controlada con vh para que quepan controles
     - Escritorio o apaisado: mantenemos proporci√≥n 3/4
  */
 .stage { height: 48vh; max-height: 62vh; }   /* antes 56/70 */
@media (min-width: 600px) and (orientation: landscape) {
  .stage { height:auto; aspect-ratio:3/4; }
}
  video, .onion {
    position:absolute; inset:0; width:100%; height:100%; object-fit:cover;
  }
  .onion { pointer-events:none; opacity:.35; }

  .hud { position:absolute; inset:auto 8px 8px 8px; display:flex; justify-content:space-between; align-items:center; gap:8px; }
  .chip { background:rgba(0,0,0,.45); padding:6px 10px; border-radius:999px; font-size:12px; backdrop-filter: blur(6px); border:1px solid rgba(255,255,255,.12) }

  button, select, input[type="range"] {
    background:#0e151d; color:#e6eef7; border:1px solid rgba(255,255,255,.12);
    border-radius:12px; padding:10px 12px; font-size:14px;
  }
  button.primary { background:linear-gradient(180deg,#1f2b38,#141d27); border-color:#2b3a4b; }
  button.accent { background:linear-gradient(180deg,#15343e,#0f262d); border-color:#255866; color:#bff2ff; }
  button:disabled { opacity:.5; pointer-events:none; }
  .big { font-size:18px; padding:12px 16px; border-radius:14px; }

  .controls { display:flex; flex-wrap:wrap; gap:8px; }
  .row { display:flex; gap:8px; align-items:center; }
  .grow { flex:1 1 auto; }

  .strip, .out { background:var(--panel); border:1px solid rgba(255,255,255,.06); border-radius:14px; padding:10px; display:grid; gap:10px; }
  .thumbs { display:grid; grid-template-columns: repeat(5, 1fr); gap:8px; }
  .thumbs img { width:100%; aspect-ratio:1/1; object-fit:cover; border-radius:10px; border:1px solid rgba(255,255,255,.08); }
  .meta { font-size:13px; color:var(--muted); display:flex; justify-content:space-between; align-items:center; }
  .out video { width:100%; border-radius:12px; border:1px solid rgba(255,255,255,.08); background:#000; }
  a.dl { color:#c6f2ff; text-decoration:none; font-weight:600; }

  .hint { font-size:12px; color:var(--muted); }
    /* üëá Pega aqu√≠ estas l√≠neas nuevas */
  .out { display:none; }              /* oculta la secci√≥n hasta tener v√≠deo */
  video { will-change: transform; }   /* ayuda en iOS */
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>üé¨ Stop-Motion con referencia transparente</h1>
    <div class="hint">Toma fotos; la √∫ltima se superpone con transparencia para alinear la siguiente.</div>
  </header>

  <main>
    <section class="cam">
      <div class="stage" id="stage">
      <video id="cam" playsinline webkit-playsinline autoplay muted></video>
        <img id="onion" class="onion" alt="onion-skin" />
        <div class="hud">
          <div class="chip" id="count">0 / 10</div>
          <div class="chip">Opacidad gu√≠a:
            <input id="opacity" type="range" min="0" max="100" value="35" style="vertical-align:middle; width:120px;">
          </div>
        </div>
      </div>

      <div class="controls">
        <div class="row grow">
          <button id="snap" class="primary big">üì∏ Capturar</button>
          <button id="undo" title="Borra la √∫ltima foto">‚Ü©Ô∏è Deshacer</button>
          <button id="reset" title="Vac√≠a todas y vuelve a 0">üóëÔ∏è Reiniciar</button>
        </div>
        <div class="row">
          <label class="row" title="C√°mara">
            C√°mara
            <select id="cameraSel">
              <option value="environment">Trasera</option>
              <option value="user">Frontal (selfie)</option>
            </select>
          </label>
          <label class="row" style="gap:6px;">
            FPS
            <select id="fpsSel">
              <option>4</option><option selected>6</option><option>8</option><option>10</option><option>12</option>
            </select>
          </label>
          <button id="make" class="accent">üéûÔ∏è Generar video</button>
        </div>
        <div class="hint">Si no ves la c√°mara: abre en <b>https</b> o <b>localhost</b>.</div>
      </div>
    </section>

    <section class="strip">
      <div class="meta"><div>Fotogramas</div><div id="meta">0/10 listos</div></div>
      <div class="thumbs" id="thumbs"></div>
    </section>

    <section class="out">
      <div class="meta"><div>Resultado</div><div class="hint">Se genera en .webm</div></div>
   <video id="out" playsinline webkit-playsinline loop muted></video>

      <div><a id="download" class="dl" href="#" download="stopmotion.webm" style="display:none;">‚¨áÔ∏è Descargar video</a></div>
    </section>
  </main>
</div>

<script>
(() => {
  const MAX_FRAMES = 10;
  const cam = document.getElementById('cam');
  const onion = document.getElementById('onion');
  const opacity = document.getElementById('opacity');
  const count = document.getElementById('count');
  const meta = document.getElementById('meta');
  const thumbs = document.getElementById('thumbs');
  const snapBtn = document.getElementById('snap');
  const undoBtn = document.getElementById('undo');
  const resetBtn = document.getElementById('reset');
  const makeBtn = document.getElementById('make');
  const outVid = document.getElementById('out');
  const dl = document.getElementById('download');
  const cameraSel = document.getElementById('cameraSel');
  const fpsSel = document.getElementById('fpsSel');

  let stream = null;
  let facingMode = cameraSel.value; // 'environment' | 'user'
  let frames = [];
  let canvas = document.createElement('canvas');
  let ctx = canvas.getContext('2d', { alpha:false });

  function uiUpdate(){
    count.textContent = `${frames.length} / ${MAX_FRAMES}`;
    meta.textContent = `${frames.length}/${MAX_FRAMES} listos`;
    snapBtn.disabled = frames.length >= MAX_FRAMES;
    undoBtn.disabled = frames.length === 0;
    makeBtn.disabled = frames.length === 0;
  }

  function setOnionOpacity(){
    onion.style.opacity = (+opacity.value/100).toFixed(2);
  }
  opacity.addEventListener('input', setOnionOpacity);

  cameraSel.addEventListener('change', async () => {
    facingMode = cameraSel.value;
    await startCamera();
  });

  async function startCamera() {
    try {
      if (stream) stream.getTracks().forEach(t => t.stop());
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode, width: { ideal: 1080 }, height: { ideal: 1440 } },
        audio: false
      });
      cam.srcObject = stream;
      await cam.play();

      // üëá Previsualizaci√≥n: espejo SOLO en frontal
      const mirror = (facingMode === 'user') ? 'scaleX(-1)' : 'none';
      cam.style.transform = mirror;
      onion.style.transform = mirror; // üëà superposici√≥n tambi√©n espejada en frontal (alineada 1:1)

      adjustCanvas();
    } catch (err) {
      alert('No se pudo acceder a la c√°mara: ' + err.message);
      console.error(err);
    }
  }

  function adjustCanvas(){
    const track = stream?.getVideoTracks?.()[0];
    const settings = track?.getSettings?.() || {};
    const w = settings.width || cam.videoWidth || 1080;
    const h = settings.height || cam.videoHeight || 1440;
    const aspect = w && h ? (w/h) : (3/4);
    let targetW = 1080;
    let targetH = Math.round(targetW / aspect);
    canvas.width = targetW;
    canvas.height = targetH;
  }

  // ‚¨áÔ∏è Dibuja el frame actual con la misma orientaci√≥n que la vista previa.
  function drawFrameToCanvas() {
    const w = canvas.width, h = canvas.height;
    ctx.save();
    if (facingMode === 'user') {
      // espejo en frontal para que la captura sea EXACTAMENTE lo que ves
      ctx.translate(w, 0);
      ctx.scale(-1, 1);
    }
    ctx.drawImage(cam, 0, 0, w, h);
    ctx.restore();
  }

  function addThumb(dataURL){
    const img = new Image();
    img.src = dataURL;
    thumbs.appendChild(img);
  }

  async function capture(){
    if (frames.length >= MAX_FRAMES) return;
    drawFrameToCanvas();
    const durl = canvas.toDataURL('image/jpeg', 0.92);
    const bmp = await createImageBitmap(canvas);
    frames.push({bmp, durl});
    onion.src = durl; // usar como gu√≠a (ya con la misma orientaci√≥n que la vista previa)
    addThumb(durl);
    uiUpdate();
    if (frames.length === MAX_FRAMES) generateVideo();
  }

  async function undo(){
    if (!frames.length) return;
    frames.pop();
    if (thumbs.lastElementChild) thumbs.removeChild(thumbs.lastElementChild);
    onion.src = frames.length ? frames[frames.length-1].durl : '';
    uiUpdate();
  }

  function resetAll(){
    frames.forEach(f => f.bmp.close?.());
    frames = [];
    thumbs.innerHTML = '';
    onion.src = '';
    outVid.src = '';
    dl.style.display = 'none';
    uiUpdate();
  }

  async function generateVideo(){
    if (!frames.length) return;

    const fps = parseInt(fpsSel.value, 10) || 6;
    const stream = canvas.captureStream(fps);
    const mime = MediaRecorder.isTypeSupported('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9' :
                 MediaRecorder.isTypeSupported('video/webm;codecs=vp8') ? 'video/webm;codecs=vp8' :
                 'video/webm';
    let recorder;
    try {
      recorder = new MediaRecorder(stream, { mimeType: mime, videoBitsPerSecond: 4_000_000 });
    } catch(e){
      alert('Tu navegador no soporta MediaRecorder para WebM.');
      return;
    }

    const chunks = [];
    recorder.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
    const done = new Promise(resolve => recorder.onstop = resolve);
    recorder.start();

    const frameDuration = 1000 / fps;
    const w = canvas.width, h = canvas.height;

    const playOnce = async (arr) => {
      for (let i=0; i<arr.length; i++){
        ctx.clearRect(0,0,w,h);
        ctx.drawImage(arr[i].bmp, 0, 0, w, h);
        await new Promise(r => setTimeout(r, frameDuration));
      }
    };

    await playOnce(frames);
    recorder.stop();
    await done;

    const blob = new Blob(chunks, { type: 'video/webm' });
    const url = URL.createObjectURL(blob);
   outVid.src = url;
outVid.setAttribute('controls','');        // a√±ade controles ahora
outVid.play().catch(()=>{});
outVid.closest('.out').style.display = 'grid';  // ‚Üê muestra la secci√≥n
dl.href = url;
dl.style.display = 'inline-block';
  }

  snapBtn.addEventListener('click', capture);
  undoBtn.addEventListener('click', undo);
  resetBtn.addEventListener('click', resetAll);
  makeBtn.addEventListener('click', generateVideo);

  setOnionOpacity();

  if (!navigator.mediaDevices?.getUserMedia) {
    alert('Tu navegador no soporta getUserMedia.');
  } else {
    startCamera();
  }

  cam.addEventListener('loadedmetadata', adjustCanvas);

  window.addEventListener('beforeunload', () => {
    stream?.getTracks?.().forEach(t => t.stop());
    frames.forEach(f => f.bmp.close?.());
  });
})();
</script>
</body>
</html>
